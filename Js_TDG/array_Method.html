<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*Array Method*/

            /*Array Methods lists*/

                /*forEach() (iterate through an array, invoking a function you specify for each element)*/
                    let data = [1,2,3,4,5];
                    let sum = 0;
                    //Compute the sum of the elements of the array
                    data.forEach((element)=> {
                        sum += element;
                    })
                    console.log(sum);

                        //Now increment each array method
                            data.forEach((element,index,itself)=> {
                                a[index] = element + 1;
                            })
                            console.log(data); //[2,3,4,5,6]

                /*map(function) (pass each element of the array and return an array containing the values returned by your function)*/
                    let a = [1,2,3];
                    a.map((element)=> {
                        return element*element;
                    })
                /*filter()*/
                    let b = [5,4,3,2,1];
                    b.filter(x => x<3); // => [2,1]
                    b.filter((x,i) => i%2 === 0) // => [5,3,1]: retrun true if the index of the array are (%===0)
                    /*Note that filter() always skip missing elements in sparse arrays*/
                        let dense = sparse.filter(()=>true);
                        /*to close the gaps and remove undefined and null elements*/
                            a = a.filter(x => x!==undefined && x!==null);

                /*find() & findIndex()*/
                    /*Unlike filter(), they stop iterating the first time the predicate finds an element*/
                        let d = [1,2,3,4,5];
                        d.findIndex(x => x===4); //=> 3: because element 4 is in index 3
                        d.findIndex(x => x < 0); // => -1: no negative numbers in the array
                        d.find(x => x%5 ===0); // => 5
                        d.find(x => x%7 ==0); // => undefined: no multiples of 7 in the array
                
                /*every() & some()*/
                    /*It return true if the function you set is match the elements in the array*/
                        let e = [1,2,3,4,5];
                        e.every(x=>x>0); //=> true: because every elements are larger tham 0
                        e.every(x=> x%2 ===0); // => false: not all values are even
                    /*It return true if some of them are match to the function you supply*/
                        let f = [1,2,3,4,5];
                        f.some(x => x%2 === 0); // => true:becaure some of them are match
                        f.some(isNaN); // => false

                /*reduce(function) & reduceRight()*/    // the second argument is initial value
                    /*reduce()*/
                        let g = [1,2,3,4,5];
                        g.reduce((x,y) => x+y, 0); // => 15; the sum of the value
                        g.reduce((x,y) => x*y, 1); // => 120; the product of the value
                        g.reduce((x,y) => (x>y)? x:y); // => 5; the largest of the value
                    /*reduceRight*/
                        let h = [2,3,4];
                        h.reduceRight((x,y)=> Math.pow(y,x)) // compute 2^(3^4)

////////////////////////////////////////////////////////////////////

                /*Flatting arrays with flat() and flatMap()*/
                    /*flat()*/
                        /*flatten n levels of nesting, default value is 1*/
                            [1,2,[3]].flat(); // => [1,2,3]
                            [1,[2,[3]]].flat(); // => [1,2,[3]]
                        /*If n > 1*/
                            let i = [1,[2,[3,[4]]]]
                            i.flat(1); // => [1,2[3,[4]]]
                            i.flat(2); // => [1,2,3[4]]
                            i.flat(3); // => [1,2,3,4]
                            i.flat(4); // => [1,2,3,4]
                    /*flatMap()*/
                        /*It is just like map(), but it automatically flat() itself*/
                            let phrases = ["hello world", "the definitive guide"];
                            let words = phrase.flatMap(phrase => phrase.spilt(""));
                            words // => ["hello", "world", "the", "definitive", "guide"]

///////////////////////////////////////////////////////////////////

                /*concat()*/
                    /*Create and return a new array that contains the elements of the original array on which concat() was invoked*/
                        let j = [1,2,3];
                        a.concat(4,5); // => [1,2,3,4,5]
                        a.concat([4,5],[6,7]) // => [1,2,3,4,5,6,7]
                        a.concat(4,[5,[6,7]]) // => [1,2,3,4,5,[6,7]]

//////////////////////////////////////////////////////////////////

                /*push() pop() shift() unshift()*/

                /*slice() splice() fill() copyWithin()*/
                    /*slice(start, end), it doesn't modify the arrayon which it is invoked*/
                        let k = [1,2,3,4,5];
                        k.slice(0,3); // => [1,2,3], end not including
                        k.slice(3); // => [4,5], which ignore the end argument
                    
                    /*splice(start, length)*/
                        let l = [1,2,3,4,5,6,7,8]
                        l.splice(4); // => [5,6,7,8], if we omit the second argument,it take the elements to the end
                        l.splice(1,2); // => [2,3], l is now [1,4,5,6,7,8]

                        /*We can put arguments in 3 and 4 position, which is the replaced element(try to change the original array's element)*/
                        l.splice(2,0,"a","b"); // =>[] a is now [1,2,"a","b",3,4,5,6,7,8] 
                        l.splice(2,2,"x","y"); // =>["a", "b"] a is now[1,2,"x","y",3,4,5,6,7,8]

                    /*fill()*/
                        let m = new Array(5);
                        a.fill(0); //=> [0,0,0,0,0]
                        a.fill(9,1); //=> [0,9,9,9,9]
                        a.fill(8,2,-1); //=> [0,9,8,8,9]

                    /*copyWithin(destination,first copied element, end copied element)*/
                    /*I want index 3 to 5 replace from index 2 */
                        let n = [1,2,3,4,5];
                        n.copyWithin(2, 3, 5);
                        n.copyWithin(0, -2);

 /////////////////////////////////////////////////////////////

                /*indexOf(find element, position start) & lastIndexOf()*/
                    let p = [0,1,2,1,0];
                    p.indexOf(1); //=> 1: p[1] is 1
                    p.indexOf(2); //=> 2: p[2] is 2
                    p.lastIndexOf(1); //=> 3: p[3] is 1 //from the end to the front
                    p.indexOf(1)

                    /*Find all occurrences of a value x in an array a and return an an array*/
                        function findAllIndex(a,x) {
                            let result = []; //create an empty array to push the find x to it
                            let len = a.length;
                            for(let position = 0; position < len; position++) {
                                a.indexOf(x,position)
                                if(position === -1) { //If nothing found, we're done.
                                    break;
                                }
                                result.push(x); //otherwise, store index in array
                            }
                            return result;
                        }

                
////////////////////////////////////////////////////////////

                /*includes()*/
                    let q = [1,true,3,NaN];
                    q.includes(true); //=> true
                    q.includes(2); //=> false
                    q.includes(NaN); //=> true
                    q.indexOf(NaN); //=> -1; indexOf can't find NaN

////////////////////////////////////////////////////////////

                /*sort() warning: watch the first argument; if return > 0,the former argument goes right*/
                    let r = ["banana","cherry","apple"];
                    r.sort(); // r == ["apple","banana","cherry"]
                    
                    /*If we want to compare numbers instead of alphabetical*/
                        let s = [33, 4 ,1111, 222];
                        s.sort(); // s == [1111, 222, 33, 4]; alphabetical order

                        s.sort(function(a,b){ 
                            return a-b; //return <0 , 0, or >0;depending on order
                        }) // s == [4, 33, 222, 1111]

                        s.sort((a,b)=>b-a); // s == [1111, 222, 33, 4]

                /*reverse()*/
                    let t = [1,2,3];
                    t.reverse(); // t == [3,2,1]

/////////////////////////////////////////////////////////////
                /*Array to String Conversion*/
                    /*join()*/
                        let u = [1,2,3];
                        u.join(); //=> "1,2,3" default is comma
                        u.join(" "); //=> "1 2 3"
                        u.join(""); //=> "123"
                        let v = new Array(10);
                        v.join("-"); //=> "----------" a string of 9 hyphens
                    /*tostring()*/
                        [1,2,3].tostring(); //=> "1,2,3"

//////////////////////////////////////////////////////
                
                /*Check whether it is an array or not*/
                    Array.isArray([]); //=> true
                    Array.isArray({}); //=> false
    </script>
</body>
</html>